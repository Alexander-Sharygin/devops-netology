# Задание

Ответьте на вопросы:

1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа: опишите ход своих мыслей и поясните, если считаете, что она могла бы быть другого типа.  
**type cd  
cd is a shell builtin
Внутренняя функция shell, встроенная потомучто реализует базовый функционал перемещения по папкам.
Могла бы быть и внешней, например как echo есть и внутренний и внешний вариант  
echo is a shell builtin  
echo is /usr/bin/echo  
echo is /bin/echo**  

2. Какая альтернатива без pipe для команды `grep <some_string> <some_file> | wc -l`   

    <details>
    <summary>Подсказка.</summary>

    `man grep` поможет в ответе на этот вопрос. 

    </details>
	
    Изучите [документ](http://www.smallo.ruhr.de/award.html) о других подобных некорректных вариантах использования pipe.  
**grep -c <some_string> <some_file>**
3. Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?  
**systemd (pstree -p)**
4. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?  
**ls 2> /dev/pts/1**
5. Получится ли одновременно передать команде файл на stdin и вывести её stdout в другой файл? Приведите работающий пример.  
**cat </home/vagrant/123.txt > 12345.txt**  
6. Получится ли, находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?  
**echo привет > /dev/tty3  
ctrl+alt+f3 перейти в консоль tty3 увидим там сообщение "привет"**
7. Выполните команду `bash 5>&1`. К чему она приведёт? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?  
**Запустится bash с файловым дискриптором 5, его вывод перенаправится в дискриптор 1 (stdout)   
echo netology > /proc/$$/fd/5 направит вывод netology в 5й файловый дискриптор процесса c pid $$ это наш bash. Который перенаправится в stdout Итого мы видим вывод в консоли Netology**
8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв отображение stdout на pty?  
	Напоминаем: по умолчанию через pipe передаётся только stdout команды слева от `|` на stdin команды справа.
Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.  
**ls выводит stdout на pty и stderr на pipe wc считает 0 строк  
ls 5>&1 1>&2 2>&5 | wc -l  
Vagrantfile   Vagrantfile_copy  
0  
ls ничего не выводит на tty, т.к. ошибка, stderr через pipe на wc который выдает 1 кол-во строк в ошибке.  
ls % 5>&1 1>&2 2>&5 | wc -l  
1**
2. Что выведет команда `cat /proc/$$/environ`? Как ещё можно получить аналогичный по содержанию вывод?  
**Вывод переменные среды нашего сеанса  
env**
1. Используя `man`, опишите, что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.
**man proc  
cmdline - Содержит командную строку для процесса, если этот процесс не является зомби. В последнем случае в этом файле ничего нет.  
exe - Содержит символическую ссылку, содержащую фактический путь к выполняемой команде.**

1. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.  
**grep sse /cat/cpuinfo**
1. При открытии нового окна терминала и `vagrant ssh` создаётся новая сессия и выделяется pty.  
	Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2.  
	
	Однако:

    ```bash
	vagrant@netology1:~$ ssh localhost 'tty'
   not a tty
    ```

	Почитайте, почему так происходит и как изменить поведение.  
**Когда мы запускаем команду на удаленном узле не выделяется tty поэтому выводить not a tty 
ssh -t localhost 'tty'**
	
1. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии.  
**запустил nano  
в другом терминале посмотрел его pid, reptyr pid**
1. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell, который запущен без `sudo` под вашим пользователем. Для решения этой проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте, что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.  
**pipe направит вывод на stdin tee которая будет запущена с повышенными правами и доступ на запсть в файл будет.**